---
title: "Vectors"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(gradethis)
knitr::opts_chunk$set(echo = FALSE)
tutorial_options(exercise.eval = FALSE)
knitr::opts_chunk$set(exercise.checker = gradethis::grade_learnr)
```

In this exercise we will go over how to work with vectors.  A vector is a variable that contains more than one value.  For example, let's say you wanted to create a list of states that are not part of the contiguous United States.  You would create that using the ``c()`` function (which stands for "Combine"):


```{r states, exercise=TRUE}
c('Hawaii', 'Alaska')
```

A vector can hold any kind of information, as long as all of the entries are of the same type (such as a number or a character string).  Let's say that we want to create a vector containing the year when each state was admitted to the United States: 1959 for Alaska, and 
#### Vectors
A vector's values can be numbers, strings, logical values, or any
other type, as long as they're all the same type. Try creating a vector of
numbers, like this:
  
The c function (c is short for Combine) creates a new vector by combining a list of values.
```{r}
c(4, 7, 9)

```

Now try creating a vector with strings:
  
Vectors cannot hold values with different modes (types). Try mixing modes and
see what happens:
```{r}
c('a', 'b', 'c')
c(1, TRUE, "three")

```
  
All the values were converted to a single mode (characters) so that the vector
can hold them all.

#### Sequence Vectors
If you need a vector with a sequence of numbers you can
create it with start:end notation. Let's make a vector with values from 5
through 9:

```{r}
5:9
```


A more versatile way to make sequences is to call the seq function. Let's do
the same thing with seq:
  
```{r}
seq(5, 9)

```

seq also allows you to use increments other than 1. Try it with steps of 0.5:
  
```{r}
seq(5, 9, 0.5)

```

Now try making a vector with integers from 9 down to 5:
  
```{r}
9:5
seq(9,5,-0.5)
```

#### Vector Access

We're going to create a vector with some strings in it for you, and store it in
the sentence variable.

You can retrieve an individual value within a vector by providing its numeric
index in square brackets. Try getting the third value:

```{r}
sentence <- c('walk', 'the', 'plank')
sentence[3]

```

Many languages start array indices at 0, but R's vector indices start at 1.
Get the first value by typing:
  
```{r}
sentence[1]

```

You can assign new values within an existing vector. Try changing the third word to "dog":
  
```{r}
sentence[3] <- "dog"
print(sentence)
```

If you add new values onto the end, the vector will grow to accommodate them.
Let's add a fourth word:

```{r}
sentence[4] <- 'to'
print(sentence)
```

You can use a vector within the square brackets to access multiple values. Try
getting the first and third words:

```{r}
sentence[c(1, 3)]

```

This means you can retrieve ranges of values. Get the second through fourth words:

```{r}
sentence[2:4]

```

You can also set ranges of values; just provide the values in a vector. Add
words 5 through 7:

```{r}
sentence[5:7] <- c('the', 'poop', 'deck')
print(sentence)
```

Now try accessing the sixth word of the sentence vector:

```{r}
sentence[6]

```

#### Vector Names

For this challenge, we'll make a 3-item vector for you, and store it in the ranks variable.

You can assign names to a vector's elements by passing a second vector filled
with names to the names assignment function, like this:

```{r}
ranks <- 1:3
names(ranks) <- c("first", "second", "third")

```

Assigning names for a vector can act as useful labels for the data. Below, you
can see what our vector looks like now.

You can also use the names to access the vector's values. Try getting the value
for the "first" rank:
  
```{r}
ranks
ranks[1]

```

Now set the current value for the "third" rank to a different value using the
name rather than the position.

```{r}
ranks["third"] <- 4

```

#### Plotting One Vector

The barplot function draws a bar chart with a vector's values. We'll make a new
vector for you, and store it in the vesselsSunk variable.

Now try passing the vector to the barplot function:
  
```{r}
vesselsSunk <- c(4, 5, 1)
barplot(vesselsSunk)

```

If you assign names to the vector's values, R will use those names as labels on
the bar plot. Let's use the names assignment function again:
  
```{r}
names(vesselsSunk) <- c("England", "France", "Norway")

```

Now, if you call barplot with the vector again, you'll see the labels:

```{r}
barplot(vesselsSunk)

```

Now, try calling barplot on a vector of integers ranging from 1 through 100:

```{r}
barplot(1:100)

```

#### Vector Math

Most arithmetic operations work just as well on vectors as they do on single
values. We'll make another sample vector for you to work with, and store it in
the a variable.

If you add a scalar (a single value) to a vector, the scalar will be added to
each value in the vector, returning a new vector with the results. Try adding 1
to each element in our vector:
  
```{r}
a <- c(1, 2, 3)
a
a + 1

```

The same is true of division, multiplication, or any other basic arithmetic.
Try dividing our vector by 2:
  
```{r}
a / 2
```

Now try multiplying our vector by 2:
  
```{r}
a * 2
```

If you add two vectors, R will take each value from each vector and add them.
We'll make a second vector for you to experiment with, and store it in the b
variable.

Try adding it to the a vector:

```{r}
b <- c(4, 5, 6)
a + b

```

Now try subtracting b from a:

```{r}
a - b
```

You can also take two vectors and compare each item. See which values in the a
vector are equal to those in a second vector:

```{r}
a == c(1, 99, 3)

```

Notice that R didn't test whether the whole vectors were equal; it checked each
value in the a vector against the value at the same index in our new vector.

Check if each value in the a vector is less than the corresponding value in
another vector:
  
```{r}
a < c(1, 99, 3)

```

Functions that normally work with scalars can operate on each element of a
vector, too. Try getting the sine of each value in our vector:
  
```{r}
sin(a)

```

Now try getting the square roots with sqrt:
  
```{r}
sqrt(a)

```

#### Scatter Plots

The plot function takes two vectors, one for X values and one for Y values, and
draws a graph of them.

Let's draw a graph showing the relationship of numbers and their sines.

First, we'll need some sample data. We'll create a vector for you with some
fractional values between 0 and 20, and store it in the x variable.

Now, try creating a second vector with the sines of those values:

```{r}
x <- seq(1, 20, 0.1)
y <- sin(x)

```

Then simply call plot with your two vectors:

```{r}
plot(x, y)

```

Great job! Notice on the graph that values from the first argument (x) are
used for the horizontal axis, and values from the second (y) for the vertical.

Your turn. We'll create a vector with some negative and positive values for
you, and store it in the values variable.

We'll also create a second vector with the absolute values of the first, and
store it in the absolutes variable.

Try plotting the vectors, with values on the horizontal axis, and absolutes on
the vertical axis.

```{r}
values <- -10:10
absolutes <- abs(values)
plot(values, absolutes)

```

#### NA Values 
Sometimes, when working with sample data, a given value isn't
available. But it's not a good idea to just throw those values out. R has a
value that explicitly indicates a sample was not available: NA. Many functions
that work with vectors treat this value specially.

We'll create a vector for you with a missing sample, and store it in the a variable.

Try to get the sum of its values, and see what the result is:
  
```{r}
a <- c(1, 3, NA, 7, 9)
sum(a)

```

The sum is considered "not available" by default because one of the vector's
values was NA. This is the responsible thing to do; R won't just blithely add
up the numbers without warning you about the incomplete data. We can
explicitly tell sum (and many other functions) to remove NA values before they
do their calculations, however.

Remember that command to bring up help for a function? Bring up documentation
for the sum function:
  
```{r}
help(sum)

```

As you see in the documentation, sum can take an optional named argument,
na.rm. It's set to FALSE by default, but if you set it to TRUE, all NA
arguments will be removed from the vector before the calculation is performed.

Try calling sum again, with na.rm set to TRUE:

```{r}
sum(a, na.rm = TRUE)

```

